services:
  postgres:
    image: postgres:16-alpine
    container_name: postgres
    restart: unless-stopped
    env_file:
      - .env
    ports:
      - "${POSTGRES_PORT}:${POSTGRES_PORT}"
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./postgres/init:/docker-entrypoint-initdb.d
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
  ttk-collector:
    build:
      context: ../ttk-collector
      dockerfile: Dockerfile
    restart: unless-stopped
    ports:
      - "${TTK_COLLECTOR_PORT}:${TTK_COLLECTOR_PORT}"
    environment:
      - NODE_ENV=${TTK_COLLECTOR_NODE_ENV}
      - PORT=${TTK_COLLECTOR_PORT}
      - NATS_URL=${NATS_URL}
      - DATABASE_URL=${TTK_DATABASE_URL}
      - HOSTNAME=${TTK_COLLECTOR_HOSTNAME}
    depends_on:
      postgres:
        condition: service_healthy
      nats:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:${TTK_COLLECTOR_PORT}/ready"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 30s

  fb-collector:
    build:
      context: ../fb-collector
      dockerfile: Dockerfile
    restart: unless-stopped
    env_file:
      - .env
    ports:
      - "${FB_COLLECTOR_PORT}:${FB_COLLECTOR_PORT}"
    environment:
      - NODE_ENV=${FB_COLLECTOR_NODE_ENV}
      - PORT=${FB_COLLECTOR_PORT}
      - NATS_URL=${NATS_URL}
      - DATABASE_URL=${FB_DATABASE_URL}
      - HOSTNAME=${FB_COLLECTOR_HOSTNAME}
    depends_on:
      postgres:
        condition: service_healthy
      nats:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:${FB_COLLECTOR_PORT}/ready"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 30s

  reporter:
    build:
      context: ../reporter
      dockerfile: Dockerfile
    restart: unless-stopped
    env_file:
      - .env
    ports:
      - "${REPORTER_PORT}:${REPORTER_PORT}"
    environment:
      - NODE_ENV=${REPORTER_NODE_ENV}
      - PORT=${REPORTER_PORT}
      - NATS_URL=${NATS_URL}
      - DATABASE_URL=${REPORTER_DATABASE_URL}
      - HOSTNAME=${REPORTER_HOSTNAME}
    depends_on:
      postgres:
        condition: service_healthy
      nats:
        condition: service_healthy
      ttk-collector:
        condition: service_healthy
      fb-collector:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:${REPORTER_PORT}/health/ready"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 30s

  publisher:
    image: andriiuni/events:latest
    container_name: publisher
    restart: unless-stopped
    environment:
      - EVENT_ENDPOINT=${EVENT_ENDPOINT}
    depends_on:
      gateway:
        condition: service_healthy

  gateway:
    build:
      context: ../gateway
      dockerfile: Dockerfile
    restart: unless-stopped
    env_file:
      - .env
    ports:
      - "${GATEWAY_PORT}:${GATEWAY_PORT}"
    environment:
      - NODE_ENV=${GATEWAY_NODE_ENV}
      - PORT=${GATEWAY_PORT}
      - NATS_URL=${NATS_URL}
      - HOSTNAME=gateway
    depends_on:
      nats:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:${GATEWAY_PORT}/ready"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 15s
    # For horizontal scaling, use docker compose up --scale gateway=3
    deploy:
      replicas: 1
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
  nats:
    image: nats:2.12-alpine
    container_name: nats
    ports:
      - "${NATS_CLIENT_PORT}:${NATS_CLIENT_PORT}" # For clients
      - "${NATS_MONITOR_PORT}:${NATS_MONITOR_PORT}" # For monitoring
    command:
      - "-js" # Enable JetStream
      - "-m=${NATS_MONITOR_PORT}" # Monitoring port
    volumes:
      - nats-data:/data
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:${NATS_MONITOR_PORT}/healthz"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 10s
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    ports:
      - "${PROMETHEUS_PORT}:${PROMETHEUS_PORT}"
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus-data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/usr/share/prometheus/console_libraries'
      - '--web.console.templates=/usr/share/prometheus/consoles'
    depends_on:
      - gateway
      - ttk-collector
      - fb-collector
      - reporter
  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    env_file:
      - .env
    ports:
      - "${GRAFANA_PORT}:3000"
    environment:
      - GF_SECURITY_ADMIN_USER=${GF_SECURITY_ADMIN_USER}
      - GF_SECURITY_ADMIN_PASSWORD=${GF_SECURITY_ADMIN_PASSWORD}
      - GF_USERS_ALLOW_SIGN_UP=${GF_USERS_ALLOW_SIGN_UP}
    volumes:
      - grafana-data:/var/lib/grafana
      - ./grafana/provisioning:/etc/grafana/provisioning
    depends_on:
      - prometheus
volumes:
  nats-data:
  postgres-data:
  prometheus-data:
  grafana-data: